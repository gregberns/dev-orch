# Kestra Docker Compose Configuration
#
# This file sets up Kestra with a PostgreSQL database backend.
# It is configured to run locally using Docker or Podman.
#
# To run with Docker Compose:
#   docker-compose up -d
#
# To run with Podman Compose:
#   podman-compose up -d
#
# The Kestra UI will be available at http://localhost:8080

services:
  postgres:
    image: postgres:16
    environment:
      - POSTGRES_USER=kestra
      - POSTGRES_PASSWORD=supersecure
      - POSTGRES_DB=kestra
    volumes:
      - ./data/postgres:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U kestra -d kestra"]
      interval: 10s
      timeout: 5s
      retries: 5

  kestra:
    image: kestra/kestra:latest
    container_name: kestra
    ports:
      - "8080:8080" # Kestra UI and API
    volumes:
      # This volume is for Kestra's internal storage (e.g., uploaded files).
      - ./data/kestra:/app/data
      # This volume mounts your local flows, enabling a "workflows as code" approach.
      - ./kestra-flows:/app/flows
      # Mount the local configuration file to a specific path for the --config flag.
      - ./kestra-config/kestra.yml:/etc/config/application.yaml
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/v1/health"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s
    # This command explicitly tells Kestra where to find its configuration file.
    command:
      ["server", "standalone", "--config", "/etc/config/application.yaml"]

  # This service is for a future API to interact with Multipass.
  # It remains commented out until needed.
  # sidecar-api:
  #   build: ./sidecar_api
  #   restart: always
  #   ports:
  #     - "5001:5001" # Expose on host for easy testing
  #   environment:
  #     # Explicitly tell the multipass client inside the container where to find the socket
  #     - MULTIPASS_SOCKET=/var/run/multipassd.socket
  #   volumes:
  #     # Mount the host's multipass socket and binary to allow the container
  #     # to control the host's multipass daemon.
  #     # On macOS, the real Multipass socket is at a specific, protected path.
  #     # We map this exact host path to the standard location that the
  #     # multipass client expects to find it *inside* the container.
  #     - /var/run/multipass_socket:/var/run/multipassd.socket
  #     - /usr/local/bin:/usr/local/bin
  #   # Add user: root to run with permissions to access the socket.
  #   # This is often necessary with Podman and macOS.
  #   user: root
